import threading
from flask import Flask, request, jsonify
import os
import time
import requests
from dotenv import load_dotenv
from generator import generate_app_code
from githubcode import GitHubManager

# Load environment variables
load_dotenv()

app = Flask(__name__)

# Load configuration from environment
STUDENT_EMAIL = os.getenv('STUDENT_EMAIL')
STUDENT_SECRET = os.getenv('STUDENT_SECRET')
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
GITHUB_USERNAME = os.getenv('GITHUB_USERNAME')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

# Initialize GitHub manager
githubcode = GitHubManager(GITHUB_TOKEN, GITHUB_USERNAME)

def verify_secret(secret):
    """Verify if the provided secret matches"""
    return secret == STUDENT_SECRET

def send_to_evaluation_url(evaluation_url, payload, max_retries=5):
    """Send POST request to evaluation URL with exponential backoff and retries"""
    delay = 1
    for attempt in range(max_retries):
        try:
            response = requests.post(
                evaluation_url,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=30 
            )
            if response.status_code == 200:
                print(f"[EVAL-POST] Successfully sent to evaluation URL: {evaluation_url}")
                return True
            else:
                print(f"[EVAL-POST] Evaluation URL returned {response.status_code}: {response.text}")
        except Exception as e:
            print(f"[EVAL-POST] Error sending to evaluation URL (attempt {attempt + 1}): {str(e)}")
        
        if attempt < max_retries - 1:
            print(f"[EVAL-POST] Retrying in {delay} seconds...")
            time.sleep(delay)
            delay *= 2
    
    print("[EVAL-POST] Failed to send to evaluation URL after all retries.")
    return False

def start_evaluation_thread(evaluation_url, payload):
    """Starts a new thread to send the evaluation POST, preventing the main Flask thread from blocking."""
    thread = threading.Thread(target=send_to_evaluation_url, args=(evaluation_url, payload))
    thread.start()
    print("[ASYNC] Evaluation thread started in background.")

def generate_readme_content(task, brief, checks, round_num):
    """Generates a detailed, professional README content block using simple Markdown."""
    
    requirements_list = chr(10).join(f'- {check}' for check in checks)

    revision_status = ""
    if round_num > 1:
        revision_status = f"""
### Project History: Revision (Round {round_num})
This application has been updated and re-deployed. The latest code incorporates revisions and additions based on the Round {round_num} brief.
"""
    
    return f"""# Project: {task.replace('-', ' ').title()}

## Overview
**Brief:** {brief}

This application was automatically generated by an **LLM-assisted development pipeline** and deployed to GitHub Pages. It is designed to be a fully compliant solution for the stated requirements.

---

## Technical Details

### Development Status (Round {round_num})
The current iteration of the code is the result of **Round {round_num}** of development.

### Technologies Used
The application is a single-page website (`index.html`) using **pure HTML, embedded CSS, and vanilla JavaScript**. It relies on modern browser features (and optionally minimal CDNs) and requires no build steps or external package managers.

---

## Functional Requirements
The application successfully addresses the following core functional and structural checks:

{requirements_list}

{revision_status}

## Usage
To view the live application, navigate to the deployed GitHub Pages URL linked above.

## Code and Licensing
The source code is contained entirely within `index.html`. This project is distributed under the **MIT License**.
"""

@app.route('/api-endpoint', methods=['POST'])
def handle_request():
    """Main endpoint to handle build and revision requests"""
    try:
        data = request.json
        
        # 0. Basic Validation
        required_fields = ['secret', 'email', 'task', 'brief', 'evaluation_url']
        if not all(field in data for field in required_fields):
            return jsonify({'error': 'Missing required fields in payload.'}), 400

        # 1. Verify secret
        if not verify_secret(data.get('secret')):
            return jsonify({'error': 'Invalid secret'}), 403
        
        # Extract request data
        email = data.get('email')
        task = data.get('task')
        round_num = data.get('round', 1)
        nonce = data.get('nonce')
        brief = data.get('brief')
        checks = data.get('checks', [])
        evaluation_url = data.get('evaluation_url')
        attachments = data.get('attachments', [])
        
        print(f"\n{'='*50}")
        print(f"Received request for Round {round_num} - Task: {task}")
        
        # Generate unique repo name based on task
        repo_name = task.replace('/', '-').replace(' ', '-')
        
        # 2. Generate app code using LLM
        is_revision = round_num > 1
        print(f"Generating {'updated' if is_revision else 'initial'} app code with LLM...")
        app_code = generate_app_code(brief, checks, attachments, GEMINI_API_KEY, is_revision=is_revision)
        
        # Check if fallback occurred (if API key is missing or LLM failed)
        # The generator.py is designed to return a specific string on failure.
        if "LLM Generation FAILED" in app_code:
             raise Exception("LLM Code Generation Failed. Check GEMINI_API_KEY and service logs.")
        
        # 3. Generate improved README content
        readme_content = generate_readme_content(task, brief, checks, round_num)
        
        # 4. Deploy or Update
        if round_num == 1:
            # Round 1: Build and Deploy
            print("Starting Round 1: Build and Deploy")
            repo_url, commit_sha, pages_url = githubcode.create_and_deploy_repo(
                repo_name=repo_name,
                app_code=app_code,
                readme_content=readme_content
            )
        else:
            # Round 2+: Revise and Update
            print(f"Starting Round {round_num}: Revise and Update")
            repo_url, commit_sha, pages_url = githubcode.update_repo(
                repo_name=repo_name,
                app_code=app_code,
                readme_content=readme_content
            )
        
        print(f"Deployment complete. Commit SHA: {commit_sha}")
        
        # 5. Prepare and start asynchronous evaluation ping
        eval_payload = {
            'email': email,
            'task': task,
            'round': round_num,
            'nonce': nonce,
            'repo_url': repo_url,
            'commit_sha': commit_sha,
            'pages_url': pages_url
        }
        
        print(f"Initiating asynchronous ping to evaluation URL: {evaluation_url}")
        start_evaluation_thread(evaluation_url, eval_payload)
        
        # 6. Return immediate success response (CRITICAL for non-blocking)
        return jsonify({
            'status': 'success',
            'message': f'Round {round_num} completed and evaluation initiated.',
            'repo_url': repo_url,
            'commit_sha': commit_sha,
            'pages_url': pages_url
        }), 200
        
    except Exception as e:
        print(f"!!! FATAL ERROR processing request: {str(e)}")
        import traceback
        
        error_message = str(e)
        if "LLM Code Generation Failed" in error_message:
            return jsonify({'error': 'LLM Generation Failure. Check your Gemini API Key.'}), 500
            
        traceback.print_exc()
        return jsonify({'error': f'Internal Server Error: {error_message}'}), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({'status': 'healthy'}), 200

if __name__ == '__main__':
    # Verify environment variables are set
    required_vars = ['STUDENT_EMAIL', 'STUDENT_SECRET', 'GITHUB_TOKEN', 
                     'GITHUB_USERNAME', 'GEMINI_API_KEY']
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        print(f"ERROR: Missing required environment variables: {', '.join(missing_vars)}")
        print("Please set them in your .env file")
        exit(1)
    
    print(f"Starting Flask app for student: {STUDENT_EMAIL}")
    print(f"GitHub username: {GITHUB_USERNAME}")
    app.run(host='0.0.0.0', port=5000, debug=True)
